The driver
----------
What do we need:
1   To set motor speed, floor lights, open door
2   To be able to respond events, such as button presses,
    floor sensors activating, obstructions.
3   But only those events that we care about!
4   Easy testing (I want to run this without an actual elevator!)

How to acheive these:
1   Expose setter functions?
2   Pass in event channels to the module corresponding to
3   the events that we care about. The module performs polling
    internally, to detect these events, and pushes them onto the
    channels.
4   We should pass in an elevator abstraction to the module.
    We can have one that interfaces with comedilib (the lift
    at the lab), and a fake elevator (the simulator perhaps).

The lift controller
-------------------
What do we need:
1   Maybe a destination queue
2   A way to tell the main thread when the lift has executed all orders in queue?
3   Add jobs to queue
4   Tell the lift when it passes a floor

How to acheive this:
    The lift controller can be a non-concurrent state machine.

Plan: When we get an update from the master, reprioritize our local priority queue,
and just do GoToFloor(closest_floor) on lift.

!!Nevermind!!

That actually won't make N lifts much more effective than 1 lift.
In order to fully exploit the fact that we have multiple lifts, we
need to know the state of all the lifts to prioritize orders.

So I propose that the master not only holds a list of all jobs, which it
sends out regularly, but also a copy of all the lifts' states.

Whenever a lift sends a status update, they include both requests as
well as that lift's state (which floor & direction).

This lets the master make decisions about which lift should take
which job.

So we get something like this:

    for select {
        case update := <-master_update:
            <synchronize list of jobs with update>
                <make sure that we don't erase any jobs that the
                 server might have mistakenly erased, but we still
                 have in our destination queue>
                <all_jobs = sync(update.jobs, all_jobs, destination_queue)>

            queue = {job in all_jobs | job.Assignee == our_id}
            <sort our_jobs by closest floor>
            queue = our_jobs
    }

UHHHH Crap!!
How do we access the destination queue _concurrently_???
WHooooops

---------------------------------

Solution: Only ever modify the queue from a single point in the program,
by a single thread.


The master will prioritize the jobs by distributing lifts to jobs.
For example, by closest lift in the same direction, or whatever.

Each lift will prioritize which order in their list to do first locally?
Or should the master do that as well?
Maybe it should.

That prioritization should preferably not be done in the lift controller module.
As that would make it harder to test?

Either way, after getting a master update, we know what our lift should be doing next.
The problem then is to tell the lift to do it.

Should the lift store a destination queue, or should we simply have a call
like GoToFloor(i)?

The motivation for keeping a destination queue, was for reliability.
For example, say that we got a status update from the master which said
that an order was finished, though we were actually _in progress_ of finishing it.
If we use a destination queue, we would still finish the order.

But that thinking is kinda weird. Because the master cannot set a
job to be finished unless it got a corrupt packet. But corrupt
packets are dismissed by checksums. So the master would never
get into such a situation in the first place.

With that in consideration, we might prefer a straightforward
    GoToFloor(i)
functionality. This, however, does not fit well into the for select {}
model. So we might just let the lift be a C-like state machine.
But that might look weird...

func LiftFSM() {
    for select {
        case floor := <- GoToFloor:
            if current_target != floor:
                current_target = floor

            switch (state) {
                case IDLE:
                    start movin
                case whatever
            }
    }
}


The lift controller might have to be a
    for select { }
thing as well. Accepting events like
    <- reached_floor
    <- door timer out
and
    <- new order
thru channels.

Since we use CHECKSUMS on our packets, we should not expect to handle
the case of orders being accidentally marked as finished by the master?

-----------------------

for select {
    case update := <- master_update:
        for job in update.Jobs
            if job.IsPriority()
                lift.DoJob <- job (THIS SHOULD NOT BLOCK THE MAIN THREAD!!!)

                So maybe we should just do
                lift.GoToFloor(job.floor)
}



Interface
---------


type LiftController interface {
    RunStatemachine(chan) ... etc
}

