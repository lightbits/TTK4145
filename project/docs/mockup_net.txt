Incase the network load grows too large, we can split
the client/master update messages into multiple packets.

For example, instead of sending all client requests in a
single packet, we can send batches of requests in multiple
packets.

--

The client's job is to tell the master that an order button
has been pressed, or that an order has been finished by the
client.

    type OrderType int
    const (
        OrderUp = iota
        OrderDown
        OrderOut
    )

    Order struct {
        Floor int
        Type  OrderType
        Done  bool
    }

    ClientUpdate struct {
        PendingUpdates  []Order
        LastPassedfloor int
    }

Pending updates can be removed (?) after we receive a master
update containing an order with identical fields (Floor, Type, Done).

* Question: Must the Done field be the same?
* Question: _Can_ we safely remove the pending update after this?

--

The master's job is to collect all client updates, and form
a job list, distributing jobs to lifts by priority. As well
as deleting jobs from this list when they are completed.

The master thus needs to know

    * Which buttons have been pressed at all panels
    * The last passed floor and current target floor
      of all lifts

The target floor can be figured out from the job listing (since
the lifts should be following it!)

    type Order struct {
        Floor      FloorNumber
        Type       OrderType
        AssignedTo LiftID
    }

    type MasterState struct {
        OrderList     []Order
        LiftPositions map[LiftID]int
    }


What do we need of the network then?
-----

Need to
* Send master updates
    List of (Floor, Type, AssignedTo) tuples
    (Don't bother sending lift positions, those become old pretty fast anyway)
* Receive master updates
* Send client update
    Local list of (Floor, Type, Done) tuples and LastPassedFloor
* Receive client update

What do we expose?
Do we make the API be

    OutgoingData
    IncomingData

channels and parse out data in the event manager,
or do we expose

    OutgoingClientUpdate
    IncomingClientUpdate
    OutgoingMasterUpdate
    IncomingMasterUpdate

channels?

The latter is what we want the network to do. The former is
what the network needs to do, but we don't care about.

The network must wrap data inside a packet.
(Protocol, Content, LengthInBytes, EndDelimiter).

The network might break into seperate packets?
Or maybe we do that on the event manager side?
But that's messy.

I'm leaning towards specific channels!!

-----

Prioritize:



for order in OrderList:
    order.AssignedTo = ClosestLift(order.Floor)

foreach lift:
    foreach order belonging to lift:

Is it enough to mark an order as "DoThisFirst", or do we also
need "ThenDoThisSecond" and "ThenDoThisThird", ...?

Subtle implementation detail!!

When do we make decisions about where our lift should go?
It is not when the lift clears an order. It is whenever we get
a master update.

The master should not abruptly change our lift's direction.
When can it change our direction then? I suppose when our lift
has reached the prioritized floor.

Anyway, this implies that we do not need more than a single tag
for the most prioritized order.

